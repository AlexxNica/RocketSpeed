// AUTOGENERATED FILE - DO NOT MODIFY!
// This file generated by Djinni from rocketspeed.djinni

package org.rocketspeed;

import java.util.ArrayList;
import java.util.concurrent.atomic.AtomicBoolean;

public abstract class ClientImpl {
    public abstract MsgId publish(int tenantId, String namespaceId, String topicName, byte[] data, PublishCallback publishCb, MsgId messageId);

    public abstract long subscribe(int tenantId, String namespaceId, String topicName, long startSeqno, MessageReceivedCallback deliverCb, SubscribeCallback subscribeCb);

    public abstract long resubscribe(SubscriptionParameters params, MessageReceivedCallback deliverCb, SubscribeCallback subscribeCb);

    public abstract void unsubscribe(long subHandle);

    public abstract void acknowledge(long subHandle, long seqno);

    public abstract void saveSubscriptions(SnapshotCallback snapshotCb);

    public abstract ArrayList<SubscriptionParameters> restoreSubscriptions();

    public abstract void close();

    public static native ClientImpl create(LogLevel logLevel, HostId cockpit, SubscriptionStorage storage);

    public static final class CppProxy extends ClientImpl
    {
        private final long nativeRef;
        private final AtomicBoolean destroyed = new AtomicBoolean(false);

        private CppProxy(long nativeRef)
        {
            if (nativeRef == 0) throw new RuntimeException("nativeRef is zero");
            this.nativeRef = nativeRef;
        }

        private native void nativeDestroy(long nativeRef);
        public void destroy()
        {
            boolean destroyed = this.destroyed.getAndSet(true);
            if (!destroyed) nativeDestroy(this.nativeRef);
        }
        protected void finalize() throws java.lang.Throwable
        {
            destroy();
            super.finalize();
        }

        @Override
        public MsgId publish(int tenantId, String namespaceId, String topicName, byte[] data, PublishCallback publishCb, MsgId messageId)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_publish(this.nativeRef, tenantId, namespaceId, topicName, data, publishCb, messageId);
        }
        private native MsgId native_publish(long _nativeRef, int tenantId, String namespaceId, String topicName, byte[] data, PublishCallback publishCb, MsgId messageId);

        @Override
        public long subscribe(int tenantId, String namespaceId, String topicName, long startSeqno, MessageReceivedCallback deliverCb, SubscribeCallback subscribeCb)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_subscribe(this.nativeRef, tenantId, namespaceId, topicName, startSeqno, deliverCb, subscribeCb);
        }
        private native long native_subscribe(long _nativeRef, int tenantId, String namespaceId, String topicName, long startSeqno, MessageReceivedCallback deliverCb, SubscribeCallback subscribeCb);

        @Override
        public long resubscribe(SubscriptionParameters params, MessageReceivedCallback deliverCb, SubscribeCallback subscribeCb)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_resubscribe(this.nativeRef, params, deliverCb, subscribeCb);
        }
        private native long native_resubscribe(long _nativeRef, SubscriptionParameters params, MessageReceivedCallback deliverCb, SubscribeCallback subscribeCb);

        @Override
        public void unsubscribe(long subHandle)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            native_unsubscribe(this.nativeRef, subHandle);
        }
        private native void native_unsubscribe(long _nativeRef, long subHandle);

        @Override
        public void acknowledge(long subHandle, long seqno)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            native_acknowledge(this.nativeRef, subHandle, seqno);
        }
        private native void native_acknowledge(long _nativeRef, long subHandle, long seqno);

        @Override
        public void saveSubscriptions(SnapshotCallback snapshotCb)
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            native_saveSubscriptions(this.nativeRef, snapshotCb);
        }
        private native void native_saveSubscriptions(long _nativeRef, SnapshotCallback snapshotCb);

        @Override
        public ArrayList<SubscriptionParameters> restoreSubscriptions()
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            return native_restoreSubscriptions(this.nativeRef);
        }
        private native ArrayList<SubscriptionParameters> native_restoreSubscriptions(long _nativeRef);

        @Override
        public void close()
        {
            assert !this.destroyed.get() : "trying to use a destroyed object";
            native_close(this.nativeRef);
        }
        private native void native_close(long _nativeRef);
    }
}
