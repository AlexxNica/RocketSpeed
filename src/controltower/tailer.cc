//  Copyright (c) 2014, Facebook, Inc.  All rights reserved.
//  This source code is licensed under the BSD-style license found in the
//  LICENSE file in the root directory of this source tree. An additional grant
//  of patent rights can be found in the PATENTS file in the same directory.
//
#include "src/controltower/tailer.h"
#include <vector>

namespace rocketspeed {

Tailer::Tailer(const std::vector<unique_ptr<ControlRoom>>& rooms,
               std::shared_ptr<LogStorage> storage,
               std::shared_ptr<Logger> info_log) :
  rooms_(rooms),
  storage_(storage),
  info_log_(info_log) {
}

Tailer::~Tailer() {
}

Status Tailer::Initialize() {
  if (reader_.size() != 0) {
    return Status::OK();  // already initialized, nothing more to do
  }
  // define a lambda for callback
  auto record_cb = [this] (const LogRecord& record) {
    int room_number = record.log_id % rooms_.size();
    ControlRoom* room = rooms_[room_number].get();

    // Convert storage record into RocketSpeed message.
    // This buffer copy can be avoided in future.
    // The sequence number that was generated by the storage
    // is stored back into the in-memory copy of the message.
    MessageData* newmsg = new MessageData();
    Slice payload = record.payload;

    // This payload is only valid as long as 'record' is valid, so need to
    // make a copy.
    std::string* data = new std::string(payload.data(), payload.size());
    Slice data_payload(*data);
    Status st = newmsg->DeSerializeStorage(&data_payload);
    if (!st.ok()) {
      LOG_WARN(info_log_,
        "Failed to deserialize message (%s).",
        st.ToString().c_str());
        info_log_->Flush();
    } else {
      LOG_INFO(info_log_,
        "Tailer received data (%.16s)@%lu for Topic(%s).",
        newmsg->GetPayload().ToString().c_str(),
        record.seqno,
        newmsg->GetTopicName().ToString().c_str());
    }
    assert(st.ok());
    newmsg->SetSequenceNumber(record.seqno);

    // forward to appropriate room
    std::unique_ptr<Message> m(newmsg);
    st = room->Forward(std::move(m), record.log_id);
    assert(st.ok());
  };

  auto gap_cb = [this] (const GapRecord& record) {
    // Log the gap.
    switch (record.type) {
      case GapType::kDataLoss:
        LOG_WARN(info_log_,
            "Data Loss in log %lu from %lu-%lu.",
            record.log_id, record.from, record.to);
        break;

      case GapType::kRetention:
        LOG_INFO(info_log_,
            "Retention gap in log %lu from %lu-%lu.",
            record.log_id, record.from, record.to);
        break;

      case GapType::kBenign:
        LOG_INFO(info_log_,
            "Benign gap in log %lu from %lu-%lu.",
            record.log_id, record.from, record.to);
        break;
    }

    // Create message to send to control room.
    // We don't know the tenant ID at this point, or the host ID. These will
    // have to be set in the control room.
    std::unique_ptr<Message> msg(new MessageGap(Tenant::InvalidTenant,
                                                HostId(),
                                                record.type,
                                                record.from,
                                                record.to));

    int room_number = record.log_id % rooms_.size();
    ControlRoom* room = rooms_[room_number].get();
    room->Forward(std::move(msg), record.log_id);
  };

  // create logdevice reader. There is one reader per ControlRoom.
  std::vector<AsyncLogReader*> handle;
  Status st = storage_->CreateAsyncReaders(rooms_.size(),
                                           record_cb,
                                           gap_cb,
                                           &handle);
  if (!st.ok()) {
    return st;
  }
  assert(handle.size() == rooms_.size());

  // store all the Readers
  for (unsigned int i = 0; i < handle.size(); i++) {
    reader_.emplace_back(handle[i]);
  }
  return Status::OK();
}

// Create a new instance of the LogStorage
Status
Tailer::CreateNewInstance(Env* env,
                          const std::vector<unique_ptr<ControlRoom>>& rooms,
                          std::shared_ptr<LogStorage> storage,
                          const URL& storage_url,
                          std::shared_ptr<Logger> info_log,
                          Tailer** tailer) {
  if (storage == nullptr) {
    // create logdevice client
    std::unique_ptr<facebook::logdevice::ClientSettings> settings(
      facebook::logdevice::ClientSettings::create());
    std::shared_ptr<facebook::logdevice::Client> client =
      facebook::logdevice::Client::create(
                           "rocketspeed.logdevice.primary",  // storage name
                           storage_url,
                           "",                               // credentials
                           std::chrono::milliseconds(1000),
                           std::move(settings));

    // created logdevice reader
    LogDeviceStorage* store;
    Status st = LogDeviceStorage::Create(client, env, &store);
    if (!st.ok()) {
      return st;
    }
    storage.reset(store);
  }
  *tailer = new Tailer(rooms, storage, info_log);
  return Status::OK();
}

// start reading from this log
Status
Tailer::StartReading(LogID logid, SequenceNumber start,
                     unsigned int room_id) const {
  if (reader_.size() == 0) {
    return Status::NotInitialized();
  }
  AsyncLogReader* r = reader_[room_id].get();
  Status st = r->Open(logid, start);
  if (st.ok()) {
    LOG_INFO(info_log_,
        "AsyncReader %u start reading logid %lu@%lu.",
        room_id, logid, start);
  } else {
    LOG_WARN(info_log_,
        "AsyncReader %u failed to start reading logid %lu@%lu (%s).",
        room_id, logid, start, st.ToString().c_str());
  }
  return st;
}

// start reading from this log
Status
Tailer::StopReading(LogID logid, unsigned int room_id) const {
  if (reader_.size() == 0) {
    return Status::NotInitialized();
  }
  AsyncLogReader* r = reader_[room_id].get();
  Status st = r->Close(logid);
  if (st.ok()) {
    LOG_INFO(info_log_,
        "AsyncReader %u stopped reading logid %lu.",
        room_id, logid);
  } else {
    LOG_WARN(info_log_,
        "AsyncReader %u failed to stop reading logid %lu (%s).",
        room_id, logid, st.ToString().c_str());
  }
  return st;
}
}  // namespace rocketspeed
