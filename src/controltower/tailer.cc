//  Copyright (c) 2014, Facebook, Inc.  All rights reserved.
//  This source code is licensed under the BSD-style license found in the
//  LICENSE file in the root directory of this source tree. An additional grant
//  of patent rights can be found in the PATENTS file in the same directory.
//
#include "src/controltower/tailer.h"
#include <vector>

namespace rocketspeed {

Tailer::Tailer(const std::vector<unique_ptr<ControlRoom>>& rooms,
               LogStorage* storage) :
  rooms_(rooms),
  storage_(storage) {
}

Tailer::~Tailer() {
}

Status Tailer::Initialize() {
  if (reader_.size() != 0) {
    return Status::OK();  // already initialized, nothing more to do
  }
  // define a lambda for callback
  auto callback = [this] (const LogRecord& record) {
    int room_number = record.logID % rooms_.size();
    ControlRoom* room = rooms_[room_number].get();

    // Convert storage record into RocketSpeed message.
    // This buffer copy can be avoided in future.
    // The sequence number that was generated by the storage
    // is stored back into the in-memory copy of the message.
    MessageData* newmsg = new MessageData();
    Status st = newmsg->DeSerialize((Slice*)(&record.payload));
    assert(st.ok());
    newmsg->SetSequenceNumber(record.sequenceNumber);

    // forward to appropriate room
    std::unique_ptr<Message> m(newmsg);
    st = room->Forward(std::move(m), record.logID);
    assert(st.ok());
  };
  // create logdevice reader. There is one reader per ControlRoom.
  std::vector<AsyncLogReader*> handle;
  Status st = storage_.get()->CreateAsyncReaders(rooms_.size(),
                                                 callback,
                                                 &handle);
  if (!st.ok()) {
    return st;
  }
  assert(handle.size() == rooms_.size());

  // store all the Readers
  for (unsigned int i = 0; i < handle.size(); i++) {
    reader_.emplace_back(handle[i]);
  }
  return Status::OK();
}

// Create a new instance of the LogStorage
Status
Tailer::CreateNewInstance(const Configuration* conf,
                          Env* env,
                          const std::vector<unique_ptr<ControlRoom>>& rooms,
                          Tailer** tailer) {
  // create logdevice client
  std::unique_ptr<facebook::logdevice::ClientSettings> settings(
    facebook::logdevice::ClientSettings::create());
  std::shared_ptr<facebook::logdevice::Client> client =
    facebook::logdevice::Client::create(
                         conf->GetStorageName(),
                         conf->GetStorageUrl(),
                         conf->GetStorageCredentials(),
                         std::chrono::milliseconds(1000),
                         std::move(settings));

  // created logdevice reader
  LogDeviceStorage* store;
  Status st = LogDeviceStorage::Create(client, env,  &store);
  if (!st.ok()) {
    return st;
  }
  *tailer = new Tailer(rooms, store);

  // Initialize the tailer
  st = (*tailer)->Initialize();
  if (!st.ok()) {
    delete *tailer;
    return st;
  }
  return Status::OK();
}

// start reading from this log
Status
Tailer::StartReading(LogID logid, SequenceNumber start,
                     unsigned int room_id) const {
  if (reader_.size() == 0) {
    return Status::NotInitialized();
  }
  AsyncLogReader* r = reader_[room_id].get();
  return r->Open(logid, start);
}

// start reading from this log
Status
Tailer::StopReading(LogID logid, unsigned int room_id) const {
  if (reader_.size() == 0) {
    return Status::NotInitialized();
  }
  AsyncLogReader* r = reader_[room_id].get();
  return r->Close(logid);
}
}  // namespace rocketspeed
