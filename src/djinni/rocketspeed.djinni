StatusCode = enum {
  Ok;
  NotFound;
  NotSupported;
  InvalidArgument;
  IOError;
  NotInitialized;
  Internal;
  Unauthorized;
  TimedOut;
}

Status = record +j {
  code: StatusCode;
  state: string;
}

MsgIdImpl = record {
  const SIZE: i32 = 16;

  guid: binary;
} deriving (eq)

HostId = record {
  hostname: string;
  port: i32;
} deriving (eq)

LogLevel = enum {
  DEBUG_LEVEL;
  INFO_LEVEL;
  WARN_LEVEL;
  ERROR_LEVEL;
  FATAL_LEVEL;
  NONE_LEVEL;
  NUM_INFO_LOG_LEVELS;
}

RetentionBase = enum {
  OneHour;
  OneDay;
  OneWeek;
}

SubscriptionRequestImpl = record {
  namespace_id: i32;
  topic_name: string;
  subscribe: bool;
  start: optional<i64>;
}

ConfigurationImpl = record {
  pilots: list<HostId>;
  copilots: list<HostId>;
}

PublishCallbackImpl = interface +j +o {
  Call(status: Status,
       namespace_id: i32,
       topic_name: string,
       message_id: MsgIdImpl,
       sequence_number: i64);
}

PublishStatus = record {
  status: Status;
  message_id: optional<MsgIdImpl>;
}

SubscribeCallbackImpl = interface +j +o {
  Call(status: Status,
       namespace_id: i32,
       topic_name: string,
       sequence_number: i64,
       subscribed: bool);
}

ReceiveCallbackImpl = interface +j +o {
  Call(namespace_id: i32,
       topic_name: string,
       sequence_number: i64,
       contents: binary);
}

SnapshotCallbackImpl = interface +j +o {
  Call(status: Status);
}

StorageType = enum {
  None;
  File;
}

WakeLockImpl = interface +j +o {
  Acquire(timeout: i64);

  Release();
}

SubscriptionStorage = record {
  type: StorageType;
  # Used only when this is a file storage
  file_path: optional<string>;
}

ClientImpl = interface +c {
  static Create(log_level: LogLevel,
                config: ConfigurationImpl,
                tenant_id: i32,
                client_id: string,
                subscribe_callback: SubscribeCallbackImpl,
                storage: SubscriptionStorage,
                wake_lock: WakeLockImpl): ClientImpl;

  Start(receive_callback: ReceiveCallbackImpl,
        restore_subscriptions: bool,
        resubscribe_from_storage: bool): Status;

  Publish(namespace_id: i32,
          topic_name: string,
          retention: RetentionBase,
          data: binary,
          message_id: optional<MsgIdImpl>,
          publish_callback: PublishCallbackImpl): PublishStatus;

  ListenTopics(names: list<SubscriptionRequestImpl>);

  Acknowledge(namespace_id: i32,
              topic_name: string,
              sequence_number: i64);

  SaveSubscriptions(snapshot_callback: SnapshotCallbackImpl);

  Close();
}


MessageCallback = interface +j {
  call(client_id: string,
       message: binary);
}

DisconnectCallback = interface +j {
  call(client_ids: list<string>);
}

ProxyImpl = interface +c {
  static create(log_level: LogLevel,
                config: ConfigurationImpl,
                num_workers: i32): ProxyImpl;

  start(message_callback: MessageCallback,
        disconnect_callback: DisconnectCallback): Status;

  forward(message: binary,
          session: i64,
          sequence: i32): Status;

  destroySession(session: i64);

  close();
}
