StatusCode = enum {
  Ok;
  NotFound;
  NotSupported;
  InvalidArgument;
  IOError;
  NotInitialized;
  Internal;
  Unauthorized;
  TimedOut;
}

Status = record +j {
  code: StatusCode;
  state: string;
}

MsgIdImpl = record {
  const SIZE: i32 = 16;

  guid: binary;
}

HostId = record {
  hostname: string;
  port: i32;
}

RetentionBase = enum {
  OneHour;
  OneDay;
  OneWeek;
}

SubscriptionStartImpl = record {
  sequence_number: i64;
  present: bool;
}

SubscriptionRequestImpl = record {
  namespace_id: i16;
  topic_name: string;
  subscribe: bool;
  sequence_number: SubscriptionStartImpl;
}

ConfigurationImpl = record {
  pilots: list<HostId>;
  copilots: list<HostId>;
  tenant_id: i16;
}

PublishCallbackImpl = interface +j +o {
  Call(status: Status,
       namespace_id: i16,
       topic_name: string,
       message_id: MsgIdImpl,
       sequence_number: i64,
       contents: binary);
}

SubscribeCallbackImpl = interface +j +o {
  Call(status: Status,
       sequence_number: i64,
       subscribed: bool);
}

ReceiveCallbackImpl = interface +j +o {
  Call(namespace_id: i16,
       topic_name: string,
       sequence_number: i64,
       contents: binary);
}

PublishStatus = record {
  status: Status;
  message_id: optional<MsgIdImpl>;
}

ClientImpl = interface +c {
  static Open(config: ConfigurationImpl,
              client_id: string,
              publish_callback: PublishCallbackImpl,
              subscribe_callback: SubscribeCallbackImpl,
              receive_callback: ReceiveCallbackImpl,
              file_path: optional<string>) : ClientImpl;

  Publish(namespace_id: i16,
          topic_name: string,
          retention: RetentionBase,
          data: binary,
          message_id: optional<MsgIdImpl>) : PublishStatus;

  ListenTopics(names: list<SubscriptionRequestImpl>);

  Acknowledge(namespace_id: i16,
              topic_name: string,
              sequence_number: i64,
              contents: binary);

  Close();
}
